package com.miracle.arcanesigils.effects.impl;

import com.miracle.arcanesigils.effects.EffectContext;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.ItemDisplay;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Grants invulnerability for a fixed number of incoming hits (not time-based).
 * Pattern based on RegisterNoKnockbackEffect.
 */
public class InvulnerabilityHitsEffect extends AbstractEffect {
    private static final Map<UUID, InvulnerabilityCounter> activeInvulnerability = new HashMap<>();

    private static class InvulnerabilityCounter {
        int hitsRemaining;
        long registeredAt;
        List<UUID> orbitingShields; // Entity UUIDs for display shields
        BukkitRunnable rotationTask;

        InvulnerabilityCounter(int hits) {
            this.hitsRemaining = hits;
            this.registeredAt = System.currentTimeMillis();
            this.orbitingShields = new ArrayList<>();
        }
    }

    public InvulnerabilityHitsEffect() {
        super("INVULNERABILITY_HITS", "Grant invulnerability for a fixed number of hits");
    }

    @Override
    public boolean execute(EffectContext context) {
        Player player = context.getPlayer();
        if (player == null) return false;

        int hits = context.getParams() != null ? context.getParams().getInt("hits", 3) : 3;

        // Remove existing invulnerability if present
        if (activeInvulnerability.containsKey(player.getUniqueId())) {
            removeInvulnerability(player.getUniqueId(), false);
        }

        InvulnerabilityCounter counter = new InvulnerabilityCounter(hits);
        activeInvulnerability.put(player.getUniqueId(), counter);

        // Spawn orbiting shield display items
        spawnShieldOrbit(player, counter, hits);

        // Start 5-second timeout task
        new BukkitRunnable() {
            @Override
            public void run() {
                if (activeInvulnerability.containsKey(player.getUniqueId())) {
                    removeInvulnerability(player.getUniqueId(), true); // timeout
                }
            }
        }.runTaskLater(getPlugin(), 5 * 20L);

        return true;
    }

    /**
     * Spawn orbiting shields (ItemDisplay entities).
     */
    private void spawnShieldOrbit(Player player, InvulnerabilityCounter counter, int shieldCount) {
        Location loc = player.getLocation().add(0, 1.5, 0); // Chest height

        for (int i = 0; i < shieldCount; i++) {
            double angle = (360.0 / shieldCount) * i;
            double radians = Math.toRadians(angle);
            double radius = 1.5;

            double x = loc.getX() + radius * Math.cos(radians);
            double z = loc.getZ() + radius * Math.sin(radians);

            ItemDisplay shield = (ItemDisplay) player.getWorld().spawnEntity(
                new Location(player.getWorld(), x, loc.getY(), z),
                EntityType.ITEM_DISPLAY
            );
            shield.setItemStack(new ItemStack(Material.NETHER_STAR));
            shield.setGravity(false);
            shield.setInvulnerable(true);
            shield.setCustomNameVisible(false);
            shield.setPersistent(false);

            counter.orbitingShields.add(shield.getUniqueId());
        }

        // Start rotation task
        startOrbitRotation(player, counter);
    }

    private void startOrbitRotation(Player player, InvulnerabilityCounter counter) {
        BukkitRunnable rotationTask = new BukkitRunnable() {
            double rotation = 0;

            @Override
            public void run() {
                if (!activeInvulnerability.containsKey(player.getUniqueId())) {
                    cancel();
                    return;
                }

                if (!player.isOnline()) {
                    cancel();
                    removeInvulnerability(player.getUniqueId(), false);
                    return;
                }

                Location center = player.getLocation().add(0, 1.5, 0);
                rotation += (360.0 / 20.0) * 0.25; // 0.25 rotations per second
                if (rotation >= 360) rotation -= 360;

                int shieldCount = counter.orbitingShields.size();
                for (int i = 0; i < shieldCount; i++) {
                    UUID shieldId = counter.orbitingShields.get(i);
                    Entity entity = Bukkit.getEntity(shieldId);
                    if (entity != null) {
                        double angle = rotation + (360.0 / shieldCount) * i;
                        double radians = Math.toRadians(angle);
                        double radius = 1.5;

                        double x = center.getX() + radius * Math.cos(radians);
                        double z = center.getZ() + radius * Math.sin(radians);

                        entity.teleport(new Location(center.getWorld(), x, center.getY(), z));
                    }
                }
            }
        };

        rotationTask.runTaskTimer(getPlugin(), 0L, 1L); // Every tick for smooth rotation
        counter.rotationTask = rotationTask;
    }

    /**
     * Check if player is invulnerable. Called from SignalHandler DEFENSE event.
     */
    public static boolean isInvulnerable(UUID playerId) {
        return activeInvulnerability.containsKey(playerId);
    }

    /**
     * Get remaining invulnerability hits for a player.
     * @return remaining hits, or 0 if not invulnerable
     */
    public static int getRemainingHits(UUID playerId) {
        InvulnerabilityCounter counter = activeInvulnerability.get(playerId);
        if (counter == null) return 0;
        return counter.hitsRemaining;
    }

    /**
     * Decrement hit counter. Remove one orbiting shield.
     */
    public static void decrementHits(UUID playerId) {
        InvulnerabilityCounter counter = activeInvulnerability.get(playerId);
        if (counter == null) return;

        counter.hitsRemaining--;

        // Remove one shield with particle effect
        if (!counter.orbitingShields.isEmpty()) {
            UUID shieldId = counter.orbitingShields.remove(0);
            Entity shield = Bukkit.getEntity(shieldId);
            if (shield != null) {
                shield.remove();
            }
        }

        if (counter.hitsRemaining <= 0) {
            removeInvulnerability(playerId, false);
        }
    }

    /**
     * Remove invulnerability and clean up shields.
     */
    private static void removeInvulnerability(UUID playerId, boolean timeout) {
        InvulnerabilityCounter counter = activeInvulnerability.remove(playerId);
        if (counter == null) return;

        // Cancel rotation task
        if (counter.rotationTask != null) {
            counter.rotationTask.cancel();
        }

        // Remove all remaining shields
        for (UUID shieldId : counter.orbitingShields) {
            Entity shield = Bukkit.getEntity(shieldId);
            if (shield != null) {
                shield.remove();
            }
        }
    }

    /**
     * Cleanup on player quit.
     */
    public static void removePlayerInvulnerability(UUID playerId) {
        removeInvulnerability(playerId, false);
    }
}
