# PHARAOH'S CURSE VICTIM INVULNERABILITY BUG ANALYSIS

**Date:** 2026-01-14  
**Investigator:** Claude Opus 4.5  
**Severity:** CRITICAL - Gameplay Breaking  
**Plugin Version:** ~1.0.556

---

## EXECUTIVE SUMMARY

After comprehensive analysis of the codebase, I've identified the root cause and multiple potential solutions for the bug where the **VICTIM** of Pharaoh's Curse becomes invulnerable to damage from **OTHER** players after the curse triggers.

**Root Cause:** The ProtocolLib respawn packet sequence used for skin changes causes client-side entity tracking issues that result in missed attack registrations on the server, making the curse victim appear invulnerable.

---

## BUG REPRODUCTION SCENARIO

1. **Player A** (victim) has Pharaoh's Curse helmet equipped
2. **Player B** (attacker) attacks Player A
3. Pharaoh's Curse triggers:
   - Player B gets STUNNED
   - Player B's skin changes to "SandOfSand"
4. **BUG:** Player A cannot take damage from **Player C**, **Player D**, etc.
5. Player B's attacks also may not register on Player A

---

## TECHNICAL ANALYSIS

### 1. Pharaoh's Curse Flow (pharaoh-set.yml lines 43-116)

```yaml
flows:
- type: SIGNAL
  trigger: DEFENSE
  chance: '{chance}'
  cooldown: 10
  nodes:
  - id: stun
    effect: STUN
    params:
      duration: '{duration}'
      target: '@Attacker'  # Correctly targets the attacker
  - id: change_skin
    effect: CHANGE_SKIN
    params:
      skin: SandOfSand
      duration: '{duration}'
      target: '@Attacker'  # Correctly targets the attacker
```

**Targeting is CORRECT** - both effects properly target `@Attacker` (Player B).

### 2. SkinChangeManager.applySkinChange() Packet Sequence

**File:** `src/main/java/com/miracle/arcanesigils/effects/SkinChangeManager.java`

When the skin change executes on Player B (the attacker), the following packets are sent to ALL viewers (including Player A, the victim):

```
SEQUENCE TIMELINE:
─────────────────────────────────────────────────────────────────────
Time 0ms:    PLAYER_INFO_REMOVE (Player B's UUID removed from tab)
Time ~1ms:   PLAYER_INFO_ADD (Player B re-added with new skin texture)
Time ~2ms:   ENTITY_DESTROY (Player B's entity ID destroyed)
Time ~3ms:   SPAWN_ENTITY (Player B's entity recreated at same location)
Time ~4ms:   ENTITY_EQUIPMENT (Player B's armor sent)
Time 50ms:   noDamageTicks forced to 10 on Player B
Time 100ms:  noDamageTicks forced to 10 on Player B (redundant)
Time 150ms:  noDamageTicks forced to 10 on Player B (redundant)
─────────────────────────────────────────────────────────────────────
```

**Critical Code Section (lines 452-490):**
```java
private void respawnPlayerEntity(Player target, Collection<? extends Player> viewers) {
    int entityId = target.getEntityId();
    
    // Destroy packet - entity disappears from all clients
    PacketContainer destroyPacket = protocolManager.createPacket(PacketType.Play.Server.ENTITY_DESTROY);
    destroyPacket.getIntLists().write(0, List.of(entityId));
    
    // Spawn packet - entity reappears with new skin
    PacketContainer spawnPacket = protocolManager.createPacket(PacketType.Play.Server.SPAWN_ENTITY);
    // ... entity spawn data ...
    
    for (Player viewer : viewers) {
        if (!viewer.equals(target) && viewer.canSee(target)) {
            protocolManager.sendServerPacket(viewer, destroyPacket);
            protocolManager.sendServerPacket(viewer, spawnPacket);
            sendEquipmentPackets(target, viewer);
        }
    }
}
```

### 3. The Core Problem: Client-Side Entity Tracking Desync

When Player A (the victim) receives these packets about Player B:

1. **ENTITY_DESTROY** - Player A's client removes Player B from its entity list
2. **SPAWN_ENTITY** - Player A's client creates a new entity record for Player B

**THE BUG:** During this transition (~50-200ms window), the client's entity tracking can become desynchronized. This affects:

- **Outbound attacks FROM Player A:** The client may not correctly identify nearby entities
- **Inbound attacks TO Player A:** This is the critical issue

**Hypothesis for victim invulnerability:** The client-server entity tracking desync may cause Player A's client to incorrectly report position/hitbox data, or cause other clients attacking Player A to have incorrect target information.

### 4. CustomImmunityModule Analysis

**File:** `src/main/java/com/miracle/arcanesigils/combat/modules/CustomImmunityModule.java`

This module maintains its own immunity tracking via `lastHitTime` map:

```java
@EventHandler(priority = EventPriority.LOWEST)
public void onDamage(EntityDamageByEntityEvent event) {
    if (event.getEntity() instanceof Player victim) {
        if (isImmune(victim)) {
            event.setCancelled(true);  // Cancel damage if victim is immune
            return;
        }
        lastHitTime.put(victim.getUniqueId(), System.currentTimeMillis());
    }
}

public boolean isImmune(Player player) {
    Long lastHit = lastHitTime.get(player.getUniqueId());
    if (lastHit == null) return false;
    int immunityTicks = config.getDamageImmunityTicks(); // Default: 10 ticks = 500ms
    return (System.currentTimeMillis() - lastHit) < (immunityTicks * 50);
}
```

**This module is NOT the direct cause** - it only provides ~500ms immunity window, which is standard Minecraft combat behavior.

### 5. Cross-Reference: AdvancedChat Interference

The codebase already contains a fix for an external plugin (AdvancedChat) that incorrectly interprets respawn packets:

```java
// SkinChangeManager.java lines 700-716
@EventHandler(priority = EventPriority.HIGH)
public void onDamageFixAdvancedChat(EntityDamageByEntityEvent event) {
    if (!(event.getDamager() instanceof Player attacker)) return;
    if (!event.isCancelled()) return;
    
    // Check if attacker has recent skin change (within 5 seconds)
    long timeSince = getTimeSinceSkinChange(attacker);
    if (timeSince >= 0 && timeSince < 5000) {
        event.setCancelled(false);  // Uncancell the event
    }
}
```

This fix only checks if the **ATTACKER** had a skin change. **It doesn't handle the case where the VICTIM is affected by a nearby player's skin change.**

---

## ROOT CAUSE DETERMINATION

The bug occurs due to a combination of factors:

1. **ProtocolLib Respawn Packet Side Effects:** The ENTITY_DESTROY + SPAWN_ENTITY sequence, while intended only for visual changes, can affect Minecraft's internal entity tracking on both client and server.

2. **Client Prediction Desync:** When a client receives these packets during combat, it may incorrectly predict entity states, leading to attacks that "miss" on the server despite appearing to connect on the client.

3. **Missing Victim-Side Handling:** The existing AdvancedChat fix only handles cases where the ATTACKER had a skin change. There's no handling for when VIEWERS of a skin change experience combat issues.

4. **Entity ID vs UUID Mismatch Window:** During the respawn, there's a brief window where the client's entity ID mapping may be stale, causing USE_ENTITY packets (attacks) to reference incorrect entities.

---

## PROPOSED SOLUTIONS

### Solution 1: Avoid Entity Respawn (Recommended)

**Approach:** Use `PLAYER_INFO` packets with `UPDATE_DISPLAY_NAME` and `UPDATE_LISTED` actions instead of the full respawn sequence.

**Why this works:** Modern Minecraft (1.19.3+) allows updating player skin via PlayerInfo packets without despawning the entity.

**Implementation:**
```java
private void applySkinChangeWithoutRespawn(Player target, SkinData skin) {
    WrappedGameProfile newProfile = createProfileWithSkin(target, skin);
    
    // Step 1: Update player info (skin texture) without removing
    PacketContainer updatePacket = protocolManager.createPacket(PacketType.Play.Server.PLAYER_INFO);
    EnumSet<EnumWrappers.PlayerInfoAction> actions = EnumSet.of(
        EnumWrappers.PlayerInfoAction.ADD_PLAYER  // Overwrites existing entry
    );
    updatePacket.getPlayerInfoActions().write(0, actions);
    // ... write player info data ...
    
    for (Player viewer : viewers) {
        protocolManager.sendServerPacket(viewer, updatePacket);
    }
    
    // Step 2: Send entity metadata update to refresh visual
    PacketContainer metadataPacket = protocolManager.createPacket(PacketType.Play.Server.ENTITY_METADATA);
    // ... entity metadata for skin layer display ...
    
    // NO ENTITY_DESTROY or SPAWN_ENTITY - entity ID remains valid
}
```

**Pros:**
- Eliminates entity tracking desync entirely
- Simpler packet sequence
- No immunity manipulation needed

**Cons:**
- May require 1.19.3+ (needs testing on 1.21)
- Skin change might not be visible until player re-enters render distance (minor)

### Solution 2: Add Victim-Side Protection in AdvancedChat Fix

**Approach:** Extend the existing fix to also uncancell events when the VICTIM has nearby players with recent skin changes.

**Implementation:**
```java
@EventHandler(priority = EventPriority.HIGH)
public void onDamageFixSkinChange(EntityDamageByEntityEvent event) {
    if (!(event.getDamager() instanceof Player attacker)) return;
    if (!event.isCancelled()) return;
    
    Player victim = null;
    if (event.getEntity() instanceof Player p) {
        victim = p;
    }
    
    // EXISTING: Check if attacker has recent skin change
    long attackerSkinMs = getTimeSinceSkinChange(attacker);
    if (attackerSkinMs >= 0 && attackerSkinMs < 5000) {
        event.setCancelled(false);
        return;
    }
    
    // NEW: Check if victim has recent skin change
    if (victim != null) {
        long victimSkinMs = getTimeSinceSkinChange(victim);
        if (victimSkinMs >= 0 && victimSkinMs < 5000) {
            event.setCancelled(false);
            return;
        }
    }
    
    // NEW: Check if ANY nearby player had recent skin change (desync propagation)
    for (Player nearby : Bukkit.getOnlinePlayers()) {
        if (nearby.getLocation().distance(attacker.getLocation()) < 50) {
            long nearbyMs = getTimeSinceSkinChange(nearby);
            if (nearbyMs >= 0 && nearbyMs < 3000) {
                event.setCancelled(false);
                return;
            }
        }
    }
}
```

**Pros:**
- Minimal code change
- Works with existing system

**Cons:**
- Reactive fix (allows damage through after it was incorrectly cancelled)
- May not catch all cases
- Doesn't address the underlying desync issue

### Solution 3: Delay Skin Change Until Combat Ends

**Approach:** Queue skin changes and apply them only when neither the target nor nearby players are in active combat.

**Implementation:**
```java
public void changeSkinSafe(Player target, String skinSource, int durationSeconds) {
    // Check if target or nearby players are in active combat
    if (isInActiveCombat(target)) {
        // Queue for later
        pendingSkinChanges.put(target.getUniqueId(), new PendingSkin(skinSource, durationSeconds));
        scheduleDelayedCheck(target);
        return;
    }
    
    // Safe to apply immediately
    changeSkin(target, skinSource, durationSeconds);
}

private boolean isInActiveCombat(Player player) {
    // Check noDamageTicks
    if (player.getNoDamageTicks() > 0) return true;
    
    // Check CustomImmunityModule
    CustomImmunityModule immunity = plugin.getLegacyCombatManager().getModule("custom-immunity");
    if (immunity != null && immunity.isImmune(player)) return true;
    
    return false;
}
```

**Pros:**
- Avoids desync during critical combat moments
- Clean separation of concerns

**Cons:**
- Delays the visual feedback of the curse
- May never apply if combat is continuous
- Reduces gameplay impact of the curse

### Solution 4: Use Alternative Visual Effect Instead of Skin Change

**Approach:** Replace CHANGE_SKIN with a visual effect that doesn't require entity respawn.

**Options:**
1. **Glowing Effect + Custom Color** - Use scoreboard team coloring
2. **Potion Particles** - Apply DARKNESS or custom particle effect
3. **Equipment Overlay** - Temporarily swap player's armor with sand-colored items
4. **Entity Passenger** - Attach a block display entity on top of the player

**Example (Glowing + Sand Particles):**
```yaml
# Instead of CHANGE_SKIN
- id: curse_visual
  effect: POTION
  params:
    potion_type: GLOWING
    duration: '{duration}'
    amplifier: 0
    target: '@Attacker'
- id: sand_particles
  effect: PARTICLE
  params:
    particle_type: FALLING_DUST
    material: SAND
    duration: '{duration}'
    follow_target: true
    target: '@Attacker'
```

**Pros:**
- No entity respawn required
- Still provides visual feedback
- Simpler implementation

**Cons:**
- Less dramatic visual effect than skin change
- May require reworking the curse's thematic identity

---

## RECOMMENDED FIX PRIORITY

| Priority | Solution | Effort | Risk | Effectiveness |
|----------|----------|--------|------|---------------|
| **1** | Solution 1: No-Respawn Skin Change | Medium | Low | HIGH |
| **2** | Solution 2: Extend AdvancedChat Fix | Low | Low | MEDIUM |
| **3** | Solution 4: Alternative Visual | Low | None | HIGH |
| **4** | Solution 3: Combat-Delay Queue | Medium | Medium | MEDIUM |

**My Recommendation:** Start with **Solution 2** as an immediate hotfix (5-10 lines of code), then implement **Solution 1** as the proper long-term fix.

---

## IMPLEMENTATION GUIDE FOR SOLUTION 2 (Quick Fix)

**File:** `src/main/java/com/miracle/arcanesigils/effects/SkinChangeManager.java`

Replace lines 700-716 with:

```java
/**
 * Fix: Override damage cancellation when ANY involved party has recent skin change.
 * This addresses issues where external plugins (AdvancedChat) or Minecraft itself
 * incorrectly cancels damage events due to entity tracking desync from respawn packets.
 */
@EventHandler(priority = EventPriority.HIGH)
public void onDamageFixSkinChangeDesync(EntityDamageByEntityEvent event) {
    if (!event.isCancelled()) return;
    
    // Get involved parties
    Player attacker = null;
    Player victim = null;
    
    if (event.getDamager() instanceof Player p) {
        attacker = p;
    } else if (event.getDamager() instanceof org.bukkit.entity.Projectile proj) {
        if (proj.getShooter() instanceof Player shooter) {
            attacker = shooter;
        }
    }
    
    if (event.getEntity() instanceof Player p) {
        victim = p;
    }
    
    if (attacker == null) return;
    
    // Check if attacker has recent skin change
    long attackerMs = getTimeSinceSkinChange(attacker);
    if (attackerMs >= 0 && attackerMs < 5000) {
        event.setCancelled(false);
        plugin.getLogger().info("[SkinFix] Uncancelled: attacker " + attacker.getName() + 
            " had skin change " + attackerMs + "ms ago");
        return;
    }
    
    // NEW: Check if victim has recent skin change  
    if (victim != null) {
        long victimMs = getTimeSinceSkinChange(victim);
        if (victimMs >= 0 && victimMs < 5000) {
            event.setCancelled(false);
            plugin.getLogger().info("[SkinFix] Uncancelled: victim " + victim.getName() + 
                " had skin change " + victimMs + "ms ago");
            return;
        }
    }
    
    // NEW: Check if any player NEAR the victim had recent skin change
    // (addresses the cross-player desync propagation issue)
    if (victim != null) {
        for (Player nearby : victim.getWorld().getPlayers()) {
            if (nearby == attacker || nearby == victim) continue;
            if (nearby.getLocation().distanceSquared(victim.getLocation()) > 2500) continue; // 50 block radius
            
            long nearbyMs = getTimeSinceSkinChange(nearby);
            if (nearbyMs >= 0 && nearbyMs < 3000) {
                event.setCancelled(false);
                plugin.getLogger().info("[SkinFix] Uncancelled: nearby player " + nearby.getName() + 
                    " had skin change " + nearbyMs + "ms ago (victim=" + victim.getName() + ")");
                return;
            }
        }
    }
}
```

---

## TESTING CHECKLIST

After implementing the fix:

- [ ] Player A (with curse) gets hit by Player B
- [ ] Curse triggers: Player B is stunned and skin changes
- [ ] Player C attacks Player A within 5 seconds - **should deal damage**
- [ ] Player D attacks Player A within 5 seconds - **should deal damage**
- [ ] Console shows `[SkinFix]` messages when damage is uncancelled
- [ ] After 5 seconds, normal immunity rules apply
- [ ] Skin change still visually works for all players

---

## ADDITIONAL DEBUGGING

If the fix doesn't resolve the issue, enable additional logging:

```java
// Add to onDamageFixSkinChangeDesync at the start:
if (event.getEntity() instanceof Player victim2) {
    plugin.getLogger().info(String.format(
        "[SkinDebug] Damage event: attacker=%s, victim=%s, cancelled=%b, damage=%.1f, " +
        "victimNoDamageTicks=%d, victimMaxNoDamageTicks=%d",
        attacker != null ? attacker.getName() : "null",
        victim2.getName(),
        event.isCancelled(),
        event.getDamage(),
        victim2.getNoDamageTicks(),
        victim2.getMaximumNoDamageTicks()
    ));
}
```

This will help identify if:
- The event is being cancelled before our handler
- The vanilla noDamageTicks is unexpectedly high
- Another plugin is interfering

---

## CONCLUSION

The bug is caused by ProtocolLib's entity respawn packets creating a client-side entity tracking desync that affects combat registration for players who witnessed the skin change. The immediate fix is to extend the existing AdvancedChat workaround to also check for recent skin changes on the victim and nearby players. The long-term fix is to implement a skin change method that doesn't require entity respawning.

**Estimated fix time:** 15 minutes for Solution 2, 1-2 hours for Solution 1.
