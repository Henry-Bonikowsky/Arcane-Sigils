# Fix Ancient Crown: Integrate Interception System with Flow System

## Problem

Ancient Crown uses a **hardcoded Java interceptor** (`AncientCrownInterceptor.java`) instead of YAML flows. This breaks the "everything in YAML" design philosophy.

**Current architecture**:
```
EntityPotionEffectEvent
  ↓
PotionEffectInterceptionListener
  ↓
InterceptionManager.fireIntercept()
  ↓
AncientCrownInterceptor.intercept() [HARDCODED]
  ↓
Modifies InterceptionEvent
```

**Desired architecture**:
```
EntityPotionEffectEvent
  ↓
PotionEffectInterceptionListener
  ↓
SignalHandler.fireSignal(POTION_EFFECT_APPLY)
  ↓
Ancient Crown YAML flows execute
  ↓
REDUCE_POTION_AMPLIFIER effect modifies InterceptionEvent
```

---

## Solution Overview

Make interception listeners fire signals through `SignalHandler` instead of calling hardcoded interceptor classes. This allows:
1. **YAML-driven interception** - Ancient Crown flows execute when effects are intercepted
2. **Consistent with other sigils** - Uses same signal/flow/effect pattern
3. **No hardcoded classes** - Everything configurable in YAML

---

## Implementation Plan

### Phase 1: Make PotionEffectInterceptionListener Fire Signals

**File**: `src/main/java/com/miracle/arcanesigils/interception/PotionEffectInterceptionListener.java`

**Changes**:
1. Get `SignalHandler` reference in constructor
2. When a potion effect is intercepted:
   - Create `InterceptionEvent` (existing code)
   - Create `EffectContext` with `POTION_EFFECT_APPLY` signal
   - Call `context.setInterceptionEvent(interceptionEvent)` to pass event
   - Fire signal: `signalHandler.processArmorEffects(player, SignalType.POTION_EFFECT_APPLY, context)`
3. After signal fires, check if `InterceptionEvent` was modified by flows
4. Apply modifications as before

**Code pattern**:
```java
// Create interception event
InterceptionEvent intercept = new InterceptionEvent(...);

// Create context and pass event
EffectContext context = EffectContext.builder(player, SignalType.POTION_EFFECT_APPLY)
    .event(event)
    .build();
context.setInterceptionEvent(intercept);
context.setCurrentPotionEffect(effect.getType());  // For conditions

// Fire signal to execute flows
signalHandler.processArmorEffects(player, SignalType.POTION_EFFECT_APPLY, context);

// Check if flows modified the event
if (intercept.isCancelled()) {
    event.setCancelled(true);
} else if (intercept.wasModified()) {
    event.setCancelled(true);
    player.addPotionEffect(new PotionEffect(...modified values...));
}
```

---

### Phase 2: Create AttributeModifierInterceptionListener

**New File**: `src/main/java/com/miracle/arcanesigils/interception/AttributeModifierInterceptionListener.java`

**Purpose**: Intercept attribute modifiers being applied to players (for Ancient Crown's attribute reduction)

**Challenges**:
- Bukkit doesn't have a direct "AttributeModifierEvent"
- Need to find where/how attribute modifiers are applied
- May need to hook into plugin's own attribute modifier system

**Approach**:
1. Research if Paper API has attribute modifier events
2. If not, hook into `ModifyAttributeEffect` or similar places where modifiers are applied
3. Fire `ATTRIBUTE_MODIFY` signal with InterceptionEvent
4. Similar pattern to potion effect listener

**Note**: This may require deeper architectural changes. Recommend starting with potion effects first, then tackling attributes.

---

### Phase 3: Remove Hardcoded AncientCrownInterceptor

**File**: `src/main/java/com/miracle/arcanesigils/listeners/ArmorChangeListener.java`

**Changes**:
1. Remove `updateAncientCrownInterceptor()` calls
2. Remove `registerAncientCrownInterceptor()` method
3. Remove `unregisterAncientCrownInterceptor()` method
4. Remove `activeInterceptors` map tracking

**Reason**: Ancient Crown will now work like any other sigil - through YAML flows that execute when signals fire.

---

### Phase 4: Keep YAML Flows (Already Correct)

**File**: `src/main/resources/sigils/seasonal-pass.yml`

**No changes needed** - the flows are already correct:
- Flow 1: POTION_EFFECT_APPLY signal → IS_NEGATIVE_EFFECT condition → REDUCE_POTION_AMPLIFIER effect
- Flow 2: ATTRIBUTE_MODIFY signal → IS_NEGATIVE_MODIFIER condition → REDUCE_ATTRIBUTE_VALUE effect

These will execute automatically once signals fire.

---

### Phase 5: Keep InterceptionManager for Cleopatra

**Files**: Keep as-is:
- `InterceptionManager.java`
- `CleopatraSuppressionInterceptor.java`
- `ApplySuppressionEffect.java`

**Reason**: Cleopatra uses the interception system differently:
- It's an **active ability** that applies a temporary suppression buff
- The interceptor is registered **dynamically** when the ability is used
- It expires after a duration
- This is a valid use case for hardcoded interceptors

Ancient Crown is **passive** (always active when equipped), so it should use flows. Cleopatra is **temporary** (registered on-demand), so hardcoded is appropriate.

---

## Critical Files to Modify

| File | Change Type | Description |
|------|-------------|-------------|
| `PotionEffectInterceptionListener.java` | **MODIFY** | Fire POTION_EFFECT_APPLY signal |
| `ArmorChangeListener.java` | **MODIFY** | Remove Ancient Crown interceptor registration |
| `AncientCrownInterceptor.java` | **DELETE** | No longer needed |
| `AttributeModifierInterceptionListener.java` | **CREATE** | Fire ATTRIBUTE_MODIFY signal (future) |

---

## Testing Plan

### Test 1: Potion Effect Reduction
1. Socket Ancient Crown T3 (60% reduction) in helmet
2. Drink Poison II potion (amplifier 1)
3. **Expected**: Amplifier reduced to 0 (60% of 1 = 0.4 → rounds down to 0)
4. **Verify**: Actionbar shows "&5&lAncient Crown! &7Debuff weakened!"
5. **Verify**: Sound plays (BLOCK_ENCHANTMENT_TABLE_USE)

### Test 2: Complete Immunity (T5)
1. Socket Ancient Crown T5 (100% reduction) in helmet
2. Drink Poison I potion
3. **Expected**: Effect completely blocked
4. **Verify**: Actionbar shows "&5&lAncient Crown! &7Debuff blocked!"
5. **Verify**: No poison effect applied

### Test 3: Positive Effects Unaffected
1. Socket Ancient Crown (any tier) in helmet
2. Drink Speed II potion
3. **Expected**: Speed effect applied normally (not reduced)
4. **Verify**: No Ancient Crown message shown

### Test 4: Debug Logging
1. Enable `debug: true` in `config.yml`
2. Trigger interception
3. **Verify**: Debug logs show flow execution

---

## Rollout Strategy

### Phase 1 (Immediate):
- Implement potion effect signal firing
- Remove hardcoded Ancient Crown interceptor
- Test with potion effects

### Phase 2 (Future):
- Research attribute modifier interception
- Implement ATTRIBUTE_MODIFY signal
- Test with attribute modifiers

---

## Advantages of This Approach

1. **YAML-driven** - Consistent with design philosophy
2. **Extensible** - Other sigils can intercept effects using flows
3. **No special cases** - Ancient Crown works like any other sigil
4. **Debuggable** - Flow execution is logged and traceable
5. **GUI-editable** - Flows can be edited in GUI (future)

---

## Edge Cases to Consider

1. **Multiple intercepting sigils** - If multiple sigils have POTION_EFFECT_APPLY flows, all will execute (priority-ordered)
2. **Suppression + Ancient Crown** - Cleopatra's hardcoded interceptor blocks, Ancient Crown's flow reduces (order matters)
3. **Non-negative effects** - IS_NEGATIVE_EFFECT condition prevents reduction of positive effects
